#include <bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin >> t;
    vector<int> v(t);
    for (int i = 0; i < t; i++)
    {
        int tt;
        cin >> tt;
        v[tt] = i;
    }
    int cnt = 0;
    for (int i = 0; i < t; ++i)
    {
        if (v[i] != i)
        {
            while (v[0] != 0)
            {
                swap(v[0], v[v[0]]);
                ++cnt;
            }
            if (v[i] != i)
            {
                swap(v[0], v[i]);
                ++cnt;
            }
        }
    }
    printf("%d\n", cnt);
}
// 题意：输入一个序列，如果某个数不在该位置，比如1不在1号位，那么需要和0交换，直到整个序列都在数所对应的位置上，过程中只能用0交换，求最小交换次数

// 分析：贪心题，要次数最小，只要每次和0交换后到达所对应的位置，简单地说就是换一次就不用再换了。
// 这里要考虑两种情况，第一种是0不在0号位，那么找到0在的位置，比如在3号位，那么和三号位对应的数交换；
// 第二种是0在0号位，找到第一个不在本位上的数交换。

// 为了方便起见，数组用来存数的位置。如下所示：